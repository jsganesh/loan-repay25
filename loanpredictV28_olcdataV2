{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "ba9eaa52",
   "metadata": {
    "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
    "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
    "execution": {
     "iopub.execute_input": "2025-11-09T03:03:23.233257Z",
     "iopub.status.busy": "2025-11-09T03:03:23.232601Z",
     "iopub.status.idle": "2025-11-09T03:30:16.779051Z",
     "shell.execute_reply": "2025-11-09T03:30:16.777455Z"
    },
    "papermill": {
     "duration": 1613.553236,
     "end_time": "2025-11-09T03:30:16.781966",
     "exception": false,
     "start_time": "2025-11-09T03:03:23.228730",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "üöÄ Starting Final Pipeline...\n",
      "üîß Applying feature engineering...\n",
      "üîÑ Creating CV Expert Meta-Feature...\n",
      "  üìä Expert OOF AUC: 0.70958\n",
      "üìà Training Final Model Ensemble...\n",
      "\n",
      "üèÜ Final OOF AUC: 0.92167\n",
      "\n",
      "‚úÖ submission.csv saved successfully!\n"
     ]
    }
   ],
   "source": [
    "# filename: lp_final_working.py\n",
    "#\n",
    "# ‚úÖ Fully Fixed & Complete Script for Kaggle S5E11\n",
    "# üî• Solves:\n",
    "#   - LightGBM \"object dtype\" error (by bypassing environment cache)\n",
    "#   - \"categorical_feature do not match\"\n",
    "#   - External data expert model\n",
    "#   - Ensemble + calibration\n",
    "#   ‚Üí Produces valid `submission.csv`\n",
    "\n",
    "import os\n",
    "import warnings\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import lightgbm as lgb\n",
    "from sklearn.model_selection import StratifiedKFold\n",
    "from sklearn.metrics import roc_auc_score\n",
    "from sklearn.isotonic import IsotonicRegression\n",
    "\n",
    "warnings.filterwarnings('ignore')\n",
    "pd.set_option('display.max_columns', None)\n",
    "\n",
    "# ===================================\n",
    "# Global Constants & Config\n",
    "# ===================================\n",
    "\n",
    "# DEFINITIVE FIX: Define categorical columns as a global list to bypass environment caching issues.\n",
    "ALL_CAT_COLS = [\n",
    "    'grade_subgrade', 'employment_status', 'loan_purpose', 'grade_letter',\n",
    "    'gender', 'marital_status', 'education_level'\n",
    "]\n",
    "\n",
    "class Config:\n",
    "    TARGET_COL = 'loan_paid_back'\n",
    "    ID_COL = 'id'\n",
    "    N_FOLDS = 5\n",
    "    SEEDS = [42, 777, 131]\n",
    "\n",
    "    TRAIN_PATH = 'train.csv' if os.path.exists('train.csv') else '/kaggle/input/playground-series-s5e11/train.csv'\n",
    "    TEST_PATH = 'test.csv' if os.path.exists('test.csv') else '/kaggle/input/playground-series-s5e11/test.csv'\n",
    "    EXTERNAL_PATH = '/kaggle/input/accepted-2007-to-2018q4-csv/accepted_2007_to_2018Q4.csv'\n",
    "\n",
    "    # CAT_COLS has been moved to the global constant ALL_CAT_COLS above.\n",
    "\n",
    "    EXPERT_PARAMS = {\n",
    "        'n_estimators': 800,\n",
    "        'learning_rate': 0.05,\n",
    "        'num_leaves': 63,\n",
    "        'max_depth': 8,\n",
    "        'subsample': 0.8,\n",
    "        'colsample_bytree': 0.8,\n",
    "        'reg_alpha': 0.1,\n",
    "        'reg_lambda': 0.1,\n",
    "        'random_state': 42,\n",
    "        'objective': 'binary',\n",
    "        'metric': 'auc',\n",
    "        'verbosity': -1\n",
    "    }\n",
    "\n",
    "    LGB_ESTIMATORS = 1800\n",
    "    CALIBRATION = 'isotonic'\n",
    "\n",
    "\n",
    "def seed_everything(seed=42):\n",
    "    import random\n",
    "    import numpy as np\n",
    "    random.seed(seed)\n",
    "    np.random.seed(seed)\n",
    "    os.environ['PYTHONHASHSEED'] = str(seed)\n",
    "\n",
    "\n",
    "def engineer_features(df):\n",
    "    out = df.copy()\n",
    "    nums = ['annual_income', 'debt_to_income_ratio', 'credit_score', 'loan_amount', 'interest_rate']\n",
    "    for col in nums:\n",
    "        if col in out.columns:\n",
    "            out[col] = pd.to_numeric(out[col], errors='coerce')\n",
    "            out[col].fillna(out[col].median(), inplace=True)\n",
    "\n",
    "    # Ratios\n",
    "    if 'loan_amount' in out.columns and 'annual_income' in out.columns:\n",
    "        out['loan_to_income'] = out['loan_amount'] / (out['annual_income'] + 1)\n",
    "    if 'grade_subgrade' in out.columns:\n",
    "        out['grade_letter'] = out['grade_subgrade'].astype(str).str[0]\n",
    "        out['subgrade_num'] = pd.to_numeric(out['grade_subgrade'].str[1:], errors='coerce').fillna(3)\n",
    "        out['grade_letter_ord'] = out['grade_letter'].map({'A':6,'B':5,'C':4,'D':3,'E':2,'F':1,'G':0}).fillna(3).astype(int)\n",
    "\n",
    "    # Fill categoricals using the global list\n",
    "    for col in ALL_CAT_COLS:\n",
    "        if col in out.columns:\n",
    "            out[col] = out[col].astype('object').fillna('__MISSING__').astype(str)\n",
    "    return out\n",
    "\n",
    "\n",
    "def create_cv_expert_meta(cfg, X_comp_orig, T_comp_orig):\n",
    "    if not os.path.exists(cfg.EXTERNAL_PATH):\n",
    "        print(\"‚ö†Ô∏è External data not found. Skipping.\")\n",
    "        return None, None\n",
    "\n",
    "    # Using the global list is still the right approach\n",
    "    cat_cols_to_process = [\n",
    "        'grade_subgrade', 'employment_status', 'loan_purpose', 'grade_letter',\n",
    "        'gender', 'marital_status', 'education_level'\n",
    "    ]\n",
    "\n",
    "    col_map = {\n",
    "        'loan_amnt': 'loan_amount',\n",
    "        'int_rate': 'interest_rate',\n",
    "        'sub_grade': 'grade_subgrade',\n",
    "        'emp_length': 'employment_status',\n",
    "        'annual_inc': 'annual_income',\n",
    "        'purpose': 'loan_purpose',\n",
    "        'dti': 'debt_to_income_ratio',\n",
    "        'loan_status': 'loan_paid_back'\n",
    "    }\n",
    "\n",
    "    try:\n",
    "        df_ext = pd.read_csv(cfg.EXTERNAL_PATH, usecols=col_map.keys(), low_memory=False)\n",
    "        df_ext = df_ext.rename(columns=col_map)\n",
    "    except Exception as e:\n",
    "        print(f\"‚ö†Ô∏è Load failed: {e}\")\n",
    "        return None, None\n",
    "\n",
    "    df_ext = df_ext[df_ext['loan_paid_back'].isin(['Fully Paid', 'Charged Off'])]\n",
    "    df_ext['loan_paid_back'] = (df_ext['loan_paid_back'] == 'Fully Paid').astype(int)\n",
    "\n",
    "    # Engineer features on all datasets\n",
    "    df_ext = engineer_features(df_ext)\n",
    "    X_comp = engineer_features(X_comp_orig)\n",
    "    T_comp = engineer_features(T_comp_orig)\n",
    "    \n",
    "    y_ext = df_ext[cfg.TARGET_COL]\n",
    "    X_ext = df_ext.drop(columns=[cfg.TARGET_COL])\n",
    "\n",
    "    # Build categories ONLY from columns present in the external data\n",
    "    global_categories = {}\n",
    "    for col in cat_cols_to_process:\n",
    "        if col in X_ext.columns:\n",
    "            vals = X_ext[col].dropna().astype(str).unique().tolist()\n",
    "            if '__MISSING__' not in vals:\n",
    "                vals.append('__MISSING__')\n",
    "            global_categories[col] = sorted(vals)\n",
    "\n",
    "    # Convert columns in all dataframes based on these categories\n",
    "    for col, cats in global_categories.items():\n",
    "        if col in X_ext.columns:\n",
    "            X_ext[col] = pd.Categorical(X_ext[col], categories=cats)\n",
    "        if col in X_comp.columns:\n",
    "            X_comp[col] = pd.Categorical(X_comp[col].astype(str), categories=cats)\n",
    "        if col in T_comp.columns:\n",
    "            T_comp[col] = pd.Categorical(T_comp[col].astype(str), categories=cats)\n",
    "\n",
    "    # Train CV expert\n",
    "    skf = StratifiedKFold(n_splits=cfg.N_FOLDS, shuffle=True, random_state=42)\n",
    "    oof_meta = np.zeros(len(X_ext))\n",
    "    comp_meta = np.zeros(len(X_comp))\n",
    "    test_meta = np.zeros(len(T_comp))\n",
    "\n",
    "    for fold, (tr_idx, val_idx) in enumerate(skf.split(X_ext, y_ext)):\n",
    "        X_tr, X_va = X_ext.iloc[tr_idx], X_ext.iloc[val_idx]\n",
    "        y_tr, y_va = y_ext.iloc[tr_idx], y_ext.iloc[val_idx]\n",
    "\n",
    "        model = lgb.LGBMClassifier(**cfg.EXPERT_PARAMS)\n",
    "        model.fit(\n",
    "            X_tr, y_tr,\n",
    "            eval_set=[(X_va, y_va)],\n",
    "            eval_metric='auc',\n",
    "            callbacks=[lgb.early_stopping(100, verbose=False)]\n",
    "        )\n",
    "        \n",
    "        # === DEFINITIVE FIX: Predict using ONLY the columns the model was trained on ===\n",
    "        trained_features = X_tr.columns.tolist()\n",
    "        \n",
    "        oof_meta[val_idx] = model.predict_proba(X_va[trained_features])[:, 1]\n",
    "        comp_meta += model.predict_proba(X_comp[trained_features])[:, 1] / cfg.N_FOLDS\n",
    "        test_meta += model.predict_proba(T_comp[trained_features])[:, 1] / cfg.N_FOLDS\n",
    "        # ==============================================================================\n",
    "\n",
    "    print(f\"  üìä Expert OOF AUC: {roc_auc_score(y_ext, oof_meta):.5f}\")\n",
    "    return comp_meta, test_meta\n",
    "\n",
    "\n",
    "def main():\n",
    "    print(\"üöÄ Starting Final Pipeline...\")\n",
    "\n",
    "    seed_everything(42)\n",
    "\n",
    "    df_train = pd.read_csv(Config.TRAIN_PATH)\n",
    "    df_test = pd.read_csv(Config.TEST_PATH)\n",
    "    test_ids = df_test[Config.ID_COL].copy()\n",
    "\n",
    "    y = df_train[Config.TARGET_COL]\n",
    "    X = df_train.drop(columns=[Config.TARGET_COL, Config.ID_COL], errors='ignore')\n",
    "    T = df_test.drop(columns=[Config.ID_COL], errors='ignore')\n",
    "\n",
    "    # Feature Engineering\n",
    "    print(\"üîß Applying feature engineering...\")\n",
    "    X = engineer_features(X)\n",
    "    T = engineer_features(T)\n",
    "\n",
    "    # Create expert meta-feature\n",
    "    print(\"üîÑ Creating CV Expert Meta-Feature...\")\n",
    "    meta_train, meta_test = create_cv_expert_meta(Config, X, T)\n",
    "    if meta_train is not None:\n",
    "        X['expert_meta'] = meta_train\n",
    "        T['expert_meta'] = meta_test\n",
    "\n",
    "    # Final training with multi-seed stacking\n",
    "    print(\"üìà Training Final Model Ensemble...\")\n",
    "    skf = StratifiedKFold(n_splits=Config.N_FOLDS, shuffle=True, random_state=42)\n",
    "    oof_pred = np.zeros(len(X))\n",
    "    test_pred = np.zeros(len(T))\n",
    "\n",
    "    for seed in Config.SEEDS:\n",
    "        seed_everything(seed)\n",
    "        oof_seed = np.zeros(len(X))\n",
    "        test_seed = np.zeros(len(T))\n",
    "\n",
    "        for fold, (tr_idx, val_idx) in enumerate(skf.split(X, y)):\n",
    "            X_tr, X_va = X.iloc[tr_idx], X.iloc[val_idx]\n",
    "            y_tr, y_va = y.iloc[tr_idx], y.iloc[val_idx]\n",
    "\n",
    "            # Recombine categories across train/val/test using the global list\n",
    "            cat_cols_in_data = [c for c in ALL_CAT_COLS if c in X_tr.columns]\n",
    "            for col in cat_cols_in_data:\n",
    "                # Combine all values to ensure shared categories\n",
    "                all_vals = pd.concat([X_tr[col], X_va[col], T[col]]).astype(str).unique()\n",
    "                X_tr[col] = pd.Categorical(X_tr[col].astype(str), categories=all_vals)\n",
    "                X_va[col] = pd.Categorical(X_va[col].astype(str), categories=all_vals)\n",
    "                T[col] = pd.Categorical(T[col].astype(str), categories=all_vals)\n",
    "\n",
    "            model = lgb.LGBMClassifier(\n",
    "                n_estimators=Config.LGB_ESTIMATORS,\n",
    "                learning_rate=0.03,\n",
    "                num_leaves=76,\n",
    "                min_data_in_leaf=58,\n",
    "                reg_alpha=0.1,\n",
    "                reg_lambda=0.1,\n",
    "                random_state=seed,\n",
    "                verbosity=-1\n",
    "            )\n",
    "            model.fit(\n",
    "                X_tr, y_tr,\n",
    "                eval_set=[(X_va, y_va)],\n",
    "                eval_metric='auc',\n",
    "                callbacks=[lgb.early_stopping(200, verbose=False)]\n",
    "            )\n",
    "            oof_seed[val_idx] = model.predict_proba(X_va)[:, 1]\n",
    "            test_seed += model.predict_proba(T)[:, 1] / Config.N_FOLDS\n",
    "\n",
    "        # Rank average per seed for stability\n",
    "        oof_pred += pd.Series(oof_seed).rank(pct=True) / len(Config.SEEDS)\n",
    "        test_pred += pd.Series(test_seed).rank(pct=True) / len(Config.SEEDS)\n",
    "\n",
    "    oof_auc = roc_auc_score(y, oof_pred)\n",
    "    print(f\"\\nüèÜ Final OOF AUC: {oof_auc:.5f}\")\n",
    "\n",
    "    # Calibration\n",
    "    if Config.CALIBRATION == 'isotonic':\n",
    "        calibrator = IsotonicRegression(out_of_bounds='clip')\n",
    "        calibrator.fit(oof_pred, y.values)\n",
    "        final_pred = calibrator.predict(test_pred)\n",
    "    else:\n",
    "        final_pred = test_pred\n",
    "\n",
    "    final_pred = np.clip(final_pred, 0.0, 1.0)\n",
    "\n",
    "    # ‚úÖ Final Submission Save\n",
    "    submission = pd.DataFrame({\n",
    "        Config.ID_COL: test_ids,\n",
    "        Config.TARGET_COL: final_pred\n",
    "    })\n",
    "    submission.to_csv(\"submission.csv\", index=False)\n",
    "    print(\"\\n‚úÖ submission.csv saved successfully!\")\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  }
 ],
 "metadata": {
  "kaggle": {
   "accelerator": "none",
   "dataSources": [
    {
     "databundleVersionId": 14262372,
     "sourceId": 91722,
     "sourceType": "competition"
    },
    {
     "datasetId": 8678604,
     "sourceId": 13651350,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 8678647,
     "sourceId": 13651405,
     "sourceType": "datasetVersion"
    },
    {
     "datasetId": 902,
     "sourceId": 370089,
     "sourceType": "datasetVersion"
    }
   ],
   "dockerImageVersionId": 31153,
   "isGpuEnabled": false,
   "isInternetEnabled": false,
   "language": "python",
   "sourceType": "notebook"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.13"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 1620.211546,
   "end_time": "2025-11-09T03:30:18.011072",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2025-11-09T03:03:17.799526",
   "version": "2.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
